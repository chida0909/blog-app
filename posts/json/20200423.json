{
  "title": "Vuexで使われる言葉を調べる",
  "permalink": "vuex-word",
  "description": null,
  "created_at": "2020-04-23T00:00:00.000Z",
  "tags": "Vuex",
  "bodyContent": "# Vuexの流れ\n![vuex-flow](vuex-flow.png)\n[https://vuex.vuejs.org/ja/](https://vuex.vuejs.org/ja/)\n\n\n# Nuxt.jsのstore\n- クラシックモードとモジュールモードの2つの書き方がある\n- クラシックモードは廃止予定なので、モジュールモードを使った方が良い\n- モジュールモードで使うには、store/index.jsがストアインスタンスを返さないようにする\n\n# 名前空間付きモジュール\n- store配下に置いたjsファイルが、ファイル名の名前をもつモジュールとして自動で登録される\n- index.jsに定義したものはグローバルに登録される\n- クラシックモードでは、namespacedオプションを使い表現する\n- store/hoge.js内ではexport defaultは使わずにexport constを使う\n\n# state\n- データの入れ物\n\n# getters\n- storeの内容から算出される値\n- gettersの呼び出しは、store.gettersと書く\n\n# stateとgettersの関係\n- コンポーネントでいうとデータ変数と算出プロパティの関係\n\n# mutations\n- stateを変更するメソッド\n- 同期処理でなければいけない\n- storeは直接変更出来ず、必ずmutationsを介して更新する\n- mutationsの呼び出しは、store.commit('mutation名')と書く\n- 第2引数（payload）があれば、それを受け取る\n\n# actions\n- stateを変更するメソッド\n- 非同期処理でなければいけない\n- actionsの呼び出しは、store.dispatch('action名')と書く\n- 処理の流れはAPI通信などの非同期処理を行った後に、mutationを呼び出してstateを更新する\n- 第一引数にはcontextオブジェクトが渡される\n- 第二引数（payload）があれば、それを受け取る\n\n# context\n- storeインスタンスが持つプロパティ、メソッドを保持するオブジェクト\n\n# dispatch\n- actionsを呼び出すためのメソッド\n- actionsの呼び出しは、store.dispatch('action名')と書く\n- 第一引数はアクションの名前を指定する\n\n# commit\n- mutationsを呼び出すためのメソッド\n- mutationsの呼び出しは、store.commit('mutation名')と書く\n- 第一引数はミューテーションの名前を指定する\n\n# ヘルパー関数\n- mapState, mapMutations, mapActions, mapGettersのこと\n- ヘルパー関数の第一引数にモジュール名、第二引数にプロパティ名orメソッド名を渡す\n\n# ヘルパー関数とスプレッド演算子\n- ...mapState, ...mapMutations, ...mapActions, ...mapGettersのこと\n- スプレッド演算子を使うと、他のmethodsやcomputedと組み合わせる事ができる\n\n```js\ncomputed: mapState([])\n```\n\n```js\ncomputed: {\n  localComputed () {},\n  ...mapState({})\n}\n```\n\n# mapState\n- computedに書く\n- mapStateは、computed: mapState(['count'])と書く\n- mapStateを使わない場合は、computed: { count() { return this.$store.state.count } }と書く\n\n# mapGetters\n- computedに書く\n\n# mapMutations\n- methodsに書く\n- mapStateは、methods: mapMutations(['increment'])と書く\n- mapStateを使わない場合は、methods: { increment() { this.$store.commit('increment') } }と書く\n\n# mapActions\n- methodsに書く\n\n# 処理の流れ\n1. ユーザがボタンをクリックし、clickイベントが発火する\n2. ローカルメソッドが実行され、その中でdispatchメソッッドが実行される\n3. dispatchによりActionsが実行される\n4. Actionsの中のcommitメソッドによりmutationsが実行される\n5. Mutationsは、stateであるcountの値を変更する。\n6. 変更された値は、ブラウザに再描写される",
  "bodyHtml": "<h1>Vuexの流れ</h1>\n<p><img src=\"vuex-flow.png\" alt=\"vuex-flow\">\n<a href=\"https://vuex.vuejs.org/ja/\">https://vuex.vuejs.org/ja/</a></p>\n<h1>Nuxt.jsのstore</h1>\n<ul>\n<li>クラシックモードとモジュールモードの2つの書き方がある</li>\n<li>クラシックモードは廃止予定なので、モジュールモードを使った方が良い</li>\n<li>モジュールモードで使うには、store/index.jsがストアインスタンスを返さないようにする</li>\n</ul>\n<h1>名前空間付きモジュール</h1>\n<ul>\n<li>store配下に置いたjsファイルが、ファイル名の名前をもつモジュールとして自動で登録される</li>\n<li>index.jsに定義したものはグローバルに登録される</li>\n<li>クラシックモードでは、namespacedオプションを使い表現する</li>\n<li>store/hoge.js内ではexport defaultは使わずにexport constを使う</li>\n</ul>\n<h1>state</h1>\n<ul>\n<li>データの入れ物</li>\n</ul>\n<h1>getters</h1>\n<ul>\n<li>storeの内容から算出される値</li>\n<li>gettersの呼び出しは、store.gettersと書く</li>\n</ul>\n<h1>stateとgettersの関係</h1>\n<ul>\n<li>コンポーネントでいうとデータ変数と算出プロパティの関係</li>\n</ul>\n<h1>mutations</h1>\n<ul>\n<li>stateを変更するメソッド</li>\n<li>同期処理でなければいけない</li>\n<li>storeは直接変更出来ず、必ずmutationsを介して更新する</li>\n<li>mutationsの呼び出しは、store.commit('mutation名')と書く</li>\n<li>第2引数（payload）があれば、それを受け取る</li>\n</ul>\n<h1>actions</h1>\n<ul>\n<li>stateを変更するメソッド</li>\n<li>非同期処理でなければいけない</li>\n<li>actionsの呼び出しは、store.dispatch('action名')と書く</li>\n<li>処理の流れはAPI通信などの非同期処理を行った後に、mutationを呼び出してstateを更新する</li>\n<li>第一引数にはcontextオブジェクトが渡される</li>\n<li>第二引数（payload）があれば、それを受け取る</li>\n</ul>\n<h1>context</h1>\n<ul>\n<li>storeインスタンスが持つプロパティ、メソッドを保持するオブジェクト</li>\n</ul>\n<h1>dispatch</h1>\n<ul>\n<li>actionsを呼び出すためのメソッド</li>\n<li>actionsの呼び出しは、store.dispatch('action名')と書く</li>\n<li>第一引数はアクションの名前を指定する</li>\n</ul>\n<h1>commit</h1>\n<ul>\n<li>mutationsを呼び出すためのメソッド</li>\n<li>mutationsの呼び出しは、store.commit('mutation名')と書く</li>\n<li>第一引数はミューテーションの名前を指定する</li>\n</ul>\n<h1>ヘルパー関数</h1>\n<ul>\n<li>mapState, mapMutations, mapActions, mapGettersのこと</li>\n<li>ヘルパー関数の第一引数にモジュール名、第二引数にプロパティ名orメソッド名を渡す</li>\n</ul>\n<h1>ヘルパー関数とスプレッド演算子</h1>\n<ul>\n<li>...mapState, ...mapMutations, ...mapActions, ...mapGettersのこと</li>\n<li>スプレッド演算子を使うと、他のmethodsやcomputedと組み合わせる事ができる</li>\n</ul>\n<pre><code class=\"hljs\">computed: mapState([])</code></pre><pre><code class=\"hljs\">computed: {\n  localComputed () {},\n  ...mapState({})\n}</code></pre><h1>mapState</h1>\n<ul>\n<li>computedに書く</li>\n<li>mapStateは、computed: mapState(['count'])と書く</li>\n<li>mapStateを使わない場合は、computed: { count() { return this.$store.state.count } }と書く</li>\n</ul>\n<h1>mapGetters</h1>\n<ul>\n<li>computedに書く</li>\n</ul>\n<h1>mapMutations</h1>\n<ul>\n<li>methodsに書く</li>\n<li>mapStateは、methods: mapMutations(['increment'])と書く</li>\n<li>mapStateを使わない場合は、methods: { increment() { this.$store.commit('increment') } }と書く</li>\n</ul>\n<h1>mapActions</h1>\n<ul>\n<li>methodsに書く</li>\n</ul>\n<h1>処理の流れ</h1>\n<ol>\n<li>ユーザがボタンをクリックし、clickイベントが発火する</li>\n<li>ローカルメソッドが実行され、その中でdispatchメソッッドが実行される</li>\n<li>dispatchによりActionsが実行される</li>\n<li>Actionsの中のcommitメソッドによりmutationsが実行される</li>\n<li>Mutationsは、stateであるcountの値を変更する。</li>\n<li>変更された値は、ブラウザに再描写される</li>\n</ol>\n",
  "dir": "posts/json",
  "base": "20200423.json",
  "ext": ".json",
  "sourceBase": "20200423.md",
  "sourceExt": ".md"
}