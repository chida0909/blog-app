{
  "title": "TypeScript 呼び出しシグネチャ オーバーロード ジェネリック",
  "permalink": "typescript-call-signature-over-load-signature",
  "description": null,
  "created_at": "2021-04-25T00:00:00.000Z",
  "tags": "TypeScript",
  "bodyContent": "呼び出しシグネチャとは、関数の型についてのTSの構文のことです。  \n\n\n```\ntype Greet = {\n    (name: string): string\n}\n\nconst greet: Greet = (name) => {\n    return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n```\n  \n## 省略記法\n  \n呼び出しシグネチャの省略記法\n  \n```\ntype Greet = (name: string) => string\n\nconst greet: Greet = (name) => {\n  return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n```\n  \n## Function型\n  \nFunction型でもアノテートは出来ます。ただし、object型がすべてのオブジェクトを表現するように、Function型はすべての関数の包括的な型であり、それが型付けする特定の関数について何も教えてくれません。  \n  \nそのため、Function型はなるべく使わずに、呼び出しシグネチャを利用すると良いです。  \n  \n```\nconst greet: Function = (name: string) => {\n    return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n```\n  \n## オーバーロードとジェネリック\n  \n単一の呼び出しシグネチャ\n  \n```\ntype Filter = {\n  (array: number[], f: (item: number) => boolean): number[]\n}\n\nconst filter: Filter = (array, f) => {\n  let result = []\n  for (let i = 0; i < array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\nconst filtered = filter([1, 2, 3, 4], _ => _ < 3)\nconsole.log(filtered) // [1, 2]\n```\n  \n### オーバーロード\n  \nオーバーロードとは複数の呼び出しシグネチャのことです。\n\n```\ntype Filter = {\n  (array: number[], f: (item: number) => boolean): number[]\n  (array: string[], f: (item: string) => boolean): string[]\n}\n\nconst filter: Filter = (array: any, f: any) => {\n  let result = []\n  for (let i = 0; i < array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\n\nconst filtered = filter([1, 2, 3, 4], _ => _ < 3)\nconsole.log(filtered) // [1, 2]\n\nconst filtered2 = filter(['a', 'b', 'c', 'd'], _ => _ < 'c')\nconsole.log(filtered2) // ['a', 'b']\n```\n  \n## ジェネリック\n  \nさらにシンプルに書くために、ジェネリックを使います。ジェネリック型パラメーターである「T」は、この型が何になるかは事前に分からないので、filter関数を呼び出すたびに、その型が何であるかをTSが推論するというものです。\n  \n```\ntype Filter = {\n  <T>(array: T[], f: (item: T) => boolean): T[]\n}\n\nconst filter: Filter = (array, f) => {\n  let result = []\n  for (let i = 0; i < array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\n\nconst filtered = filter([1, 2, 3, 4], _ => _ < 3)\nconsole.log(filtered) // [1, 2]\n\nconst filtered2 = filter(['a', 'b', 'c', 'd'], _ => _ < 'c')\nconsole.log(filtered2) // ['a', 'b']\n```",
  "bodyHtml": "<p>呼び出しシグネチャとは、関数の型についてのTSの構文のことです。</p>\n<pre><code>type Greet = {\n    (name: string): string\n}\n\nconst greet: Greet = (name) =&gt; {\n    return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n</code></pre>\n<h2>省略記法</h2>\n<p>呼び出しシグネチャの省略記法</p>\n<pre><code>type Greet = (name: string) =&gt; string\n\nconst greet: Greet = (name) =&gt; {\n  return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n</code></pre>\n<h2>Function型</h2>\n<p>Function型でもアノテートは出来ます。ただし、object型がすべてのオブジェクトを表現するように、Function型はすべての関数の包括的な型であり、それが型付けする特定の関数について何も教えてくれません。</p>\n<p>そのため、Function型はなるべく使わずに、呼び出しシグネチャを利用すると良いです。</p>\n<pre><code>const greet: Function = (name: string) =&gt; {\n    return `hello ${name}`\n}\n\nconsole.log(greet('tanaka')) // hello tanaka\n</code></pre>\n<h2>オーバーロードとジェネリック</h2>\n<p>単一の呼び出しシグネチャ</p>\n<pre><code>type Filter = {\n  (array: number[], f: (item: number) =&gt; boolean): number[]\n}\n\nconst filter: Filter = (array, f) =&gt; {\n  let result = []\n  for (let i = 0; i &lt; array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\nconst filtered = filter([1, 2, 3, 4], _ =&gt; _ &lt; 3)\nconsole.log(filtered) // [1, 2]\n</code></pre>\n<h3>オーバーロード</h3>\n<p>オーバーロードとは複数の呼び出しシグネチャのことです。</p>\n<pre><code>type Filter = {\n  (array: number[], f: (item: number) =&gt; boolean): number[]\n  (array: string[], f: (item: string) =&gt; boolean): string[]\n}\n\nconst filter: Filter = (array: any, f: any) =&gt; {\n  let result = []\n  for (let i = 0; i &lt; array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\n\nconst filtered = filter([1, 2, 3, 4], _ =&gt; _ &lt; 3)\nconsole.log(filtered) // [1, 2]\n\nconst filtered2 = filter(['a', 'b', 'c', 'd'], _ =&gt; _ &lt; 'c')\nconsole.log(filtered2) // ['a', 'b']\n</code></pre>\n<h2>ジェネリック</h2>\n<p>さらにシンプルに書くために、ジェネリックを使います。ジェネリック型パラメーターである「T」は、この型が何になるかは事前に分からないので、filter関数を呼び出すたびに、その型が何であるかをTSが推論するというものです。</p>\n<pre><code>type Filter = {\n  &lt;T&gt;(array: T[], f: (item: T) =&gt; boolean): T[]\n}\n\nconst filter: Filter = (array, f) =&gt; {\n  let result = []\n  for (let i = 0; i &lt; array.length; i++) {\n    let item = array[i]\n    if (f(item)) result.push(item)\n  }\n  return result\n}\n\nconst filtered = filter([1, 2, 3, 4], _ =&gt; _ &lt; 3)\nconsole.log(filtered) // [1, 2]\n\nconst filtered2 = filter(['a', 'b', 'c', 'd'], _ =&gt; _ &lt; 'c')\nconsole.log(filtered2) // ['a', 'b']\n</code></pre>\n",
  "dir": "posts/json",
  "base": "20210425.json",
  "ext": ".json",
  "sourceBase": "20210425.md",
  "sourceExt": ".md"
}