{
  "title": "非同期処理のpromiseについて",
  "permalink": "js-asynchronous-promise",
  "description": null,
  "created_at": "2020-04-27T00:00:00.000Z",
  "tags": "JavaScript",
  "bodyContent": "コードの評価の仕方として、\b\b同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。\n\n```js\nconsole.log(\"hello\")\nconsole.log(\"world\")\n// hello\n// world\n```\n\n一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと\b、worldの後にhelloが呼ばれる事が分かります。\n```js\nsetTimeout(() => console.log('hello'), 300)\nconsole.log('world')\n// world\n// hello\n```\n\n# promiseとは\nPromiseはES2015で導入された非同期処理の結果を表す、ビルトインオブジェクトです。\n\n# Promiseの状態\nnew Promiseでインスタンス化したpromiseオブジェクトには、3つの状態が存在します。\n\n- Pending：promiseオブジェクトが作成された初期状態です\n- Fulfilled（フルフィールド）：処理が成功して完了したことを意味します\n- Rejected：処理が失敗したことを意味します\n\npendingは処理が成功するとfulfilledに、失敗するとrejectedに変わります。\n\n# 単純なコード\nPromiseは、非同期処理を同期処理風に表現してくれます。  \n\n処理が成功すればresolveを、失敗すればrejectを呼び出します。そしてpromise.thenで値を受け取れます。\n```js\nconst promise = new Promise((resolve, reject) => resolve())\npromise.then(() => console.log(\"OK\")) // OK\n```\n  \n# resolveに引数を渡す\nresolveに引数を渡すことができます。\n\n```js\nconst promise = new Promise((resolve, reject) => resolve(\"OK\"))\npromise.then(result => console.log(result)) // OK\n```\n  \n# resolve()メソッド\nnew演算子を使わずにPromise.resolve()メソッドを用いる事も可能です。resolveメソッドがPromiseオブジェクトを返します。\n```js\nPromise.resolve().then(() => console.log(\"OK\"))\n```\n  \n# Promiseチェーン\nPromiseチェーンで上から順にthenを実行できます。\n```js\nnew Promise((resolve, reject) => {\n  console.log(\"Initial\")\n  resolve()\n})\n  .then(() => console.log(\"OK1\"))\n  .then(() => console.log(\"OK2\"))\n  .then(() => console.log(\"OK3\"))\n```\n  \n# Promise.all()\nPromise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。\n```js\nconst func1 = () => \"OK1\"\nconst func2 = () => \"OK2\"\nconst func3 = () => \"OK3\"\n\nPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {\n  console.log(result1, result2, result3) // OK1 OK2 OK3\n})\n```\n\n# PromiseとVue\n試しにVue.jsで書きました。\n\n```vue\n<template>\n  <div>\n    <button @click=\"start\">開始</button>\n  </div>\n</template>\n\n<script>\nimport axios from \"axios\";\n\nexport default {\n  data() {\n    return {\n      data: []\n    };\n  },\n  methods: {\n    getData() {\n      return new Promise((resolve, reject) => {\n        axios\n          .get(\"https://jsonplaceholder.typicode.com/posts\")\n          .then(response => {\n            this.data = response.data[0];\n            resolve();\n          })\n          .catch(error => this.error);\n      });\n    },\n    start() {\n      this.getData().then(() => {\n        console.log(this.data);\n      });\n    }\n  }\n};\n</script>\n```\n\n# まとめ\n- 同期処理：プログラムを上から下へ順番に1つずつ処理をしていくこと\n- 非同期処理：処理を実行した後に、結果を待たずにすぐ次の処理を実行すること\n- Promise：非同期処理を同期処理風に表現したもの\n- Promiseオブジェクトの作成：newを使ってPromiseのインスタンスを作成する\n- resolve：非同期処理が成功した時に呼び出されるメソッド\n- reject：非同期処理が失敗した時に呼び出されるメソッド\n- then：Promiseの結果（resolveされた時の処理、catchでrejectされた時の処理）を受け取る\n- チェーン：複数の処理を連結させる処理\n- Promise.all：すべての非同期処理が完了した時点で、resolveを返す処理\n\n# 参考\n- [Promise - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- [JavaScript Promiseの本](https://azu.github.io/promises-book/)",
  "bodyHtml": "<p>コードの評価の仕方として、\b\b同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"world\"</span>)\n<span class=\"hljs-comment\">// hello</span>\n<span class=\"hljs-comment\">// world</span></code></pre><p>一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと\b、worldの後にhelloが呼ばれる事が分かります。</p>\n<pre><code class=\"hljs\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>), <span class=\"hljs-number\">300</span>)\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world'</span>)\n<span class=\"hljs-comment\">// world</span>\n<span class=\"hljs-comment\">// hello</span></code></pre><h1>promiseとは</h1>\n<p>PromiseはES2015で導入された非同期処理の結果を表す、ビルトインオブジェクトです。</p>\n<h1>Promiseの状態</h1>\n<p>new Promiseでインスタンス化したpromiseオブジェクトには、3つの状態が存在します。</p>\n<ul>\n<li>Pending：promiseオブジェクトが作成された初期状態です</li>\n<li>Fulfilled（フルフィールド）：処理が成功して完了したことを意味します</li>\n<li>Rejected：処理が失敗したことを意味します</li>\n</ul>\n<p>pendingは処理が成功するとfulfilledに、失敗するとrejectedに変わります。</p>\n<h1>単純なコード</h1>\n<p>Promiseは、非同期処理を同期処理風に表現してくれます。</p>\n<p>処理が成功すればresolveを、失敗すればrejectを呼び出します。そしてpromise.thenで値を受け取れます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> resolve())\npromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>)) <span class=\"hljs-comment\">// OK</span></code></pre><h1>resolveに引数を渡す</h1>\n<p>resolveに引数を渡すことができます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> resolve(<span class=\"hljs-string\">\"OK\"</span>))\npromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(result)) <span class=\"hljs-comment\">// OK</span></code></pre><h1>resolve()メソッド</h1>\n<p>new演算子を使わずにPromise.resolve()メソッドを用いる事も可能です。resolveメソッドがPromiseオブジェクトを返します。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>))</code></pre><h1>Promiseチェーン</h1>\n<p>Promiseチェーンで上から順にthenを実行できます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Initial\"</span>)\n  resolve()\n})\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK1\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK2\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK3\"</span>))</code></pre><h1>Promise.all()</h1>\n<p>Promise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> func1 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK1\"</span>\n<span class=\"hljs-keyword\">const</span> func2 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK2\"</span>\n<span class=\"hljs-keyword\">const</span> func3 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK3\"</span>\n\n<span class=\"hljs-built_in\">Promise</span>.all([func1(), func2(), func3()]).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">[result1, result2, result3]</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(result1, result2, result3) <span class=\"hljs-comment\">// OK1 OK2 OK3</span>\n})</code></pre><h1>PromiseとVue</h1>\n<p>試しにVue.jsで書きました。</p>\n<pre><code class=\"hljs\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"start\"&gt;開始&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from \"axios\";\n\nexport default {\n  data() {\n    return {\n      data: []\n    };\n  },\n  methods: {\n    getData() {\n      return new Promise((resolve, reject) =&gt; {\n        axios\n          .get(\"https://jsonplaceholder.typicode.com/posts\")\n          .then(response =&gt; {\n            this.data = response.data[0];\n            resolve();\n          })\n          .catch(error =&gt; this.error);\n      });\n    },\n    start() {\n      this.getData().then(() =&gt; {\n        console.log(this.data);\n      });\n    }\n  }\n};\n&lt;/script&gt;</code></pre><h1>まとめ</h1>\n<ul>\n<li>同期処理：プログラムを上から下へ順番に1つずつ処理をしていくこと</li>\n<li>非同期処理：処理を実行した後に、結果を待たずにすぐ次の処理を実行すること</li>\n<li>Promise：非同期処理を同期処理風に表現したもの</li>\n<li>Promiseオブジェクトの作成：newを使ってPromiseのインスタンスを作成する</li>\n<li>resolve：非同期処理が成功した時に呼び出されるメソッド</li>\n<li>reject：非同期処理が失敗した時に呼び出されるメソッド</li>\n<li>then：Promiseの結果（resolveされた時の処理、catchでrejectされた時の処理）を受け取る</li>\n<li>チェーン：複数の処理を連結させる処理</li>\n<li>Promise.all：すべての非同期処理が完了した時点で、resolveを返す処理</li>\n</ul>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></li>\n<li><a href=\"https://azu.github.io/promises-book/\">JavaScript Promiseの本</a></li>\n</ul>\n",
  "dir": "posts/json",
  "base": "20200427.json",
  "ext": ".json",
  "sourceBase": "20200427.md",
  "sourceExt": ".md"
}