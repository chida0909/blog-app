{
  "title": "promiseの非同期処理について",
  "permalink": "js-asynchronous",
  "description": null,
  "created_at": "2020-04-27T00:00:00.000Z",
  "tags": "JavaScript",
  "bodyContent": "コードの評価の仕方として、\b\b同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。\n\n```js\nconsole.log(\"hello\");\nconsole.log(\"world\");\n// hello\n// world\n```\n\n一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと\b、worldの後にhelloが呼ばれる事が分かります。\n```js\nsetTimeout(() => console.log('hello'), 300);\nconsole.log('world');\n// world\n// hello\n```\n\n# promise\n\nPromiseはES2015で導入された非同期処理の結果を表す、ビルトインオブジェクトです。\n\n## 単純なコード\nPromiseは、非同期処理を同期処理風に表現してくれます。  \n\n処理が成功すればresolveを失敗すればrejectを呼び出します。そしてthenを呼び出すことで値を受け取れます。\n```js\nconst promise = new Promise((resolve, reject) => resolve());\npromise.then(() => console.log(\"OK\")); // OK\n```\n  \n## resolveに引数を渡す\nresolveに引数を渡すことができます。\n\n```js\nconst promise = new Promise((resolve, reject) => resolve(\"OK\"));\npromise.then(result => console.log(result)); // OK\n```\n  \n## resolve()メソッド\nnew演算子を使わずにPromise.resolve()メソッドを用いる事も可能です。resolveメソッドがPromiseオブジェクトを返します。\n```js\nPromise.resolve().then(() => console.log(\"OK\"));\n```\n  \n## Promiseチェーン\nPromiseチェーンで上から順にthenを実行できます。\n```js\nnew Promise((resolve, reject) => {\n  console.log(\"Initial\");\n  resolve();\n})\n  .then(() => console.log(\"OK1\"))\n  .then(() => console.log(\"OK2\"))\n  .then(() => console.log(\"OK3\"));\n```\n  \n## Promise.all()\nPromise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。\n```js\nconst func1 = () => \"OK1\";\nconst func2 = () => \"OK2\";\nconst func3 = () => \"OK3\";\n\nPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {\n  console.log(result1, result2, result3); // OK1 OK2 OK3\n});\n```\n\n## PromiseとVue\n試しにVue.jsで書きました。Promiseを使っているおかげで、非同期処理を同期的に書けています。Consoleには001 -> 002の順で出力されます。\n```js\n<template>\n  <div>\n    <button @click=\"start\">開始</button>\n  </div>\n</template>\n\n<script>\nimport axios from \"axios\";\nexport default {\n  methods: {\n    start() {\n      const result = axios\n        .get(\"https://jsonplaceholder.typicode.com/posts\")\n        .then(response => {\n          console.log(\"001\");\n          return response;\n        });\n\n      Promise.all([result]).then(([res]) => {\n        console.log(\"002\");\n      });\n    }\n  }\n};\n</script>\n```",
  "bodyHtml": "<p>コードの評価の仕方として、\b\b同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"hello\"</span>);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"world\"</span>);\n<span class=\"hljs-comment\">// hello</span>\n<span class=\"hljs-comment\">// world</span></code></pre><p>一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと\b、worldの後にhelloが呼ばれる事が分かります。</p>\n<pre><code class=\"hljs\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>), <span class=\"hljs-number\">300</span>);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world'</span>);\n<span class=\"hljs-comment\">// world</span>\n<span class=\"hljs-comment\">// hello</span></code></pre><h1>promise</h1>\n<p>PromiseはES2015で導入された非同期処理の結果を表す、ビルトインオブジェクトです。</p>\n<h2>単純なコード</h2>\n<p>Promiseは、非同期処理を同期処理風に表現してくれます。</p>\n<p>処理が成功すればresolveを失敗すればrejectを呼び出します。そしてthenを呼び出すことで値を受け取れます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> resolve());\npromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>)); <span class=\"hljs-comment\">// OK</span></code></pre><h2>resolveに引数を渡す</h2>\n<p>resolveに引数を渡すことができます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> resolve(<span class=\"hljs-string\">\"OK\"</span>));\npromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(result)); <span class=\"hljs-comment\">// OK</span></code></pre><h2>resolve()メソッド</h2>\n<p>new演算子を使わずにPromise.resolve()メソッドを用いる事も可能です。resolveメソッドがPromiseオブジェクトを返します。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>));</code></pre><h2>Promiseチェーン</h2>\n<p>Promiseチェーンで上から順にthenを実行できます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Initial\"</span>);\n  resolve();\n})\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK1\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK2\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK3\"</span>));</code></pre><h2>Promise.all()</h2>\n<p>Promise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> func1 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK1\"</span>;\n<span class=\"hljs-keyword\">const</span> func2 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK2\"</span>;\n<span class=\"hljs-keyword\">const</span> func3 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK3\"</span>;\n\n<span class=\"hljs-built_in\">Promise</span>.all([func1(), func2(), func3()]).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">[result1, result2, result3]</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(result1, result2, result3); <span class=\"hljs-comment\">// OK1 OK2 OK3</span>\n});</code></pre><h2>PromiseとVue</h2>\n<p>試しにVue.jsで書きました。Promiseを使っているおかげで、非同期処理を同期的に書けています。Consoleには001 -&gt; 002の順で出力されます。</p>\n<pre><code class=\"hljs\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"start\"&gt;開始&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from \"axios\";\nexport default {\n  methods: {\n    start() {\n      const result = axios\n        .get(\"https://jsonplaceholder.typicode.com/posts\")\n        .then(response =&gt; {\n          console.log(\"001\");\n          return response;\n        });\n\n      Promise.all([result]).then(([res]) =&gt; {\n        console.log(\"002\");\n      });\n    }\n  }\n};\n&lt;/script&gt;</code></pre>",
  "dir": "posts/json",
  "base": "20200427.json",
  "ext": ".json",
  "sourceBase": "20200427.md",
  "sourceExt": ".md"
}