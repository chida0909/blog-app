{
  "title": "非同期処理のpromiseについて",
  "permalink": "js-asynchronous-promise",
  "description": null,
  "created_at": "2020-04-27T00:00:00.000Z",
  "tags": "JavaScript",
  "bodyContent": "コードの評価の仕方として、同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。\n\n```js\nconsole.log(\"hello\")\nconsole.log(\"world\")\n// hello\n// world\n```\n\n一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと、worldの後にhelloが呼ばれる事が分かります。\n```js\nsetTimeout(() => console.log('hello'), 300)\nconsole.log('world')\n// world\n// hello\n```\n\n# Promiseとは\nPromiseとは、標準ビルトインオブジェクトで非同期処理の結果を返してくれます。Promiseオブジェクトを作成するには、Promiseコンストラクタをnewでインスタンス化します。\n\n```js\nconst promise = new Promise((resolve, reject) => {});\n```\n\nnewによって生成されたpromiseオブジェクトにはpromiseの値を resolve(成功) / reject(失敗) した時に呼ばれるコールバック関数を登録するためにpromise.then()というインスタンスメソッドがあります。\n\n```js\nconst promise = new Promise((resolve, reject) => {});\npromise.then(onFulfilled, onRejected);\n```\n\n- resolve(成功)した時：onFulfilled が呼ばれる\n- reject(失敗)した時：onRejected が呼ばれる\n\n# 処理の流れ\n\n```js\nfunction asyncFunction() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(\"Hello world\");\n    }, 5);\n  });\n}\n\nasyncFunction().then((value) => {\n  console.log(value); // 'Hello world'\n}).catch((error) => {\n  console.error(error);\n});\n```\n\n1. Promiseコンストラクタをnewして、promiseオブジェクトを返します\n2. 1のpromiseオブジェクトに対して、.thenで値が返ってきた時のコールバックを設定します\n\n# 状態\nnew Promiseでインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。\n\n- Fulfilled（フルフィールド）\nresolve(成功)した時です。このときonFulfilledが呼ばれます。\n\n- Rejected\nreject(失敗)した時です。このときonRejectedが呼ばれます。\n\n- Pending\npromiseオブジェクトが作成された初期状態等の時です。\n\nPendingは処理が成功するとFulfilledに、失敗するとRejectedに変わります。\n\n# 静的メソッド\nPromiseというグローバルオブジェクトにはいくつかの静的なメソッドが存在します。Promise.all()やPromise.resolve()などが該当します。静的メソッドなのでnewは不要になります。\n\n## Promise.all()\nPromise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。\n\n```js\nconst func1 = () => \"OK1\"\nconst func2 = () => \"OK2\"\nconst func3 = () => \"OK3\"\n\nPromise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {\n  console.log(result1, result2, result3) // OK1 OK2 OK3\n})\n```\n\n## Promise.resolve()\nPromise.resolve()という静的メソッドは、new Promise()のショートカットとなるメソッドです。\n\n```js\nnew Promise(resolve => {\n  resolve();\n}).then(() => console.log(\"OK\"));\n\n```\n\n```js\nPromise.resolve().then(value => {\n  console.log(\"OK\");\n});\n```\n\n# Promiseチェーン\npromiseはメソッドチェーンで繋げて書くことが出来ます。\n\n```js\nnew Promise((resolve, reject) => {\n  console.log(\"Initial\")\n  resolve()\n})\n  .then(() => console.log(\"OK1\"))\n  .then(() => console.log(\"OK2\"))\n  .then(() => console.log(\"OK3\"))\n```\n\n# PromiseとVue\n試しにVue.jsで書きました。\n\n```vue\n<template>\n  <div>\n    <button @click=\"start\">開始</button>\n  </div>\n</template>\n\n<script>\nimport axios from \"axios\";\n\nexport default {\n  data() {\n    return {\n      data: []\n    };\n  },\n  methods: {\n    getData() {\n      return new Promise((resolve, reject) => {\n        axios\n          .get(\"https://jsonplaceholder.typicode.com/posts\")\n          .then(response => {\n            this.data = response.data[0];\n            resolve();\n          })\n          .catch(error => this.error);\n      });\n    },\n    start() {\n      this.getData().then(() => {\n        console.log(this.data);\n      });\n    }\n  }\n};\n</script>\n```\n\n# まとめ\n- 同期処理：プログラムを上から下へ順番に1つずつ処理をしていくこと\n- 非同期処理：処理を実行した後に、結果を待たずにすぐ次の処理を実行すること\n- Promiseオブジェクトの作成：newを使ってPromiseのインスタンスを作成する\n- resolve：非同期処理が成功した時に呼び出されるメソッド\n- reject：非同期処理が失敗した時に呼び出されるメソッド\n- then：Promiseの結果（resolveされた時の処理、catchでrejectされた時の処理）を受け取る\n- チェーン：複数の処理を連結させる処理\n- Promise.all：すべての非同期処理が完了した時点で、resolveを返す処理\n\n# 用語一覧\n- オブジェクト\nオブジェクトには、データを扱うためのプロパティとメソッドが含まれています。JavaやC++、C#などの言語ではこれをクラスと呼びます。プロパティやメソッドをまとめておいたもの、つまり他の言語のクラスに相当するものをJavaScriptではオブジェクトと呼んでいます。\n\nJavaScriptのオブジェクトは、実行環境の一部として組み込み済みなため、ユーザー自身が独自に作成しなくても使えます。\n\n- インスタンス化\nオブジェクトを生成することです。\n\n- コンストラクタ\nインスタンスを作成する際に、初期化を行うメソッドのことです。\n\n- インスタンスメソッド\nインスタンス化されたオブジェクトから呼び出したメソッドのことです。  \nthen, catch\n\n- 静的メソッド\nインスタンスを生成しなくても直接呼び出せるメソッドです。  \nPromise.all, Promise.resolve, Promise.rejectなど\n\n# 参考\n- [Promise - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- [JavaScript Promiseの本](https://azu.github.io/promises-book/)",
  "bodyHtml": "<p>コードの評価の仕方として、同期処理（sync）と非同期処理（async）があります。同期処理はコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"world\"</span>)\n<span class=\"hljs-comment\">// hello</span>\n<span class=\"hljs-comment\">// world</span></code></pre><p>一方、非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を行います。非同期処理の代表的な関数setTimeoutを使うと、worldの後にhelloが呼ばれる事が分かります。</p>\n<pre><code class=\"hljs\">setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span>), <span class=\"hljs-number\">300</span>)\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'world'</span>)\n<span class=\"hljs-comment\">// world</span>\n<span class=\"hljs-comment\">// hello</span></code></pre><h1>Promiseとは</h1>\n<p>Promiseとは、標準ビルトインオブジェクトで非同期処理の結果を返してくれます。Promiseオブジェクトを作成するには、Promiseコンストラクタをnewでインスタンス化します。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {});</code></pre><p>newによって生成されたpromiseオブジェクトにはpromiseの値を resolve(成功) / reject(失敗) した時に呼ばれるコールバック関数を登録するためにpromise.then()というインスタンスメソッドがあります。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {});\npromise.then(onFulfilled, onRejected);</code></pre><ul>\n<li>resolve(成功)した時：onFulfilled が呼ばれる</li>\n<li>reject(失敗)した時：onRejected が呼ばれる</li>\n</ul>\n<h1>処理の流れ</h1>\n<pre><code class=\"hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">asyncFunction</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      resolve(<span class=\"hljs-string\">\"Hello world\"</span>);\n    }, <span class=\"hljs-number\">5</span>);\n  });\n}\n\nasyncFunction().then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(value); <span class=\"hljs-comment\">// 'Hello world'</span>\n}).catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.error(error);\n});</code></pre><ol>\n<li>Promiseコンストラクタをnewして、promiseオブジェクトを返します</li>\n<li>1のpromiseオブジェクトに対して、.thenで値が返ってきた時のコールバックを設定します</li>\n</ol>\n<h1>状態</h1>\n<p>new Promiseでインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。</p>\n<ul>\n<li>\n<p>Fulfilled（フルフィールド）\nresolve(成功)した時です。このときonFulfilledが呼ばれます。</p>\n</li>\n<li>\n<p>Rejected\nreject(失敗)した時です。このときonRejectedが呼ばれます。</p>\n</li>\n<li>\n<p>Pending\npromiseオブジェクトが作成された初期状態等の時です。</p>\n</li>\n</ul>\n<p>Pendingは処理が成功するとFulfilledに、失敗するとRejectedに変わります。</p>\n<h1>静的メソッド</h1>\n<p>Promiseというグローバルオブジェクトにはいくつかの静的なメソッドが存在します。Promise.all()やPromise.resolve()などが該当します。静的メソッドなのでnewは不要になります。</p>\n<h2>Promise.all()</h2>\n<p>Promise.all()で複数の処理を並行に開始し、すべてが終了するのを待つことができます。所謂、並列処理が可能です。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> func1 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK1\"</span>\n<span class=\"hljs-keyword\">const</span> func2 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK2\"</span>\n<span class=\"hljs-keyword\">const</span> func3 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">\"OK3\"</span>\n\n<span class=\"hljs-built_in\">Promise</span>.all([func1(), func2(), func3()]).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">[result1, result2, result3]</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(result1, result2, result3) <span class=\"hljs-comment\">// OK1 OK2 OK3</span>\n})</code></pre><h2>Promise.resolve()</h2>\n<p>Promise.resolve()という静的メソッドは、new Promise()のショートカットとなるメソッドです。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n  resolve();\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>));</code></pre><pre><code class=\"hljs\"><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK\"</span>);\n});</code></pre><h1>Promiseチェーン</h1>\n<p>promiseはメソッドチェーンで繋げて書くことが出来ます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Initial\"</span>)\n  resolve()\n})\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK1\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK2\"</span>))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK3\"</span>))</code></pre><h1>PromiseとVue</h1>\n<p>試しにVue.jsで書きました。</p>\n<pre><code class=\"hljs\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"start\"&gt;開始&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from \"axios\";\n\nexport default {\n  data() {\n    return {\n      data: []\n    };\n  },\n  methods: {\n    getData() {\n      return new Promise((resolve, reject) =&gt; {\n        axios\n          .get(\"https://jsonplaceholder.typicode.com/posts\")\n          .then(response =&gt; {\n            this.data = response.data[0];\n            resolve();\n          })\n          .catch(error =&gt; this.error);\n      });\n    },\n    start() {\n      this.getData().then(() =&gt; {\n        console.log(this.data);\n      });\n    }\n  }\n};\n&lt;/script&gt;</code></pre><h1>まとめ</h1>\n<ul>\n<li>同期処理：プログラムを上から下へ順番に1つずつ処理をしていくこと</li>\n<li>非同期処理：処理を実行した後に、結果を待たずにすぐ次の処理を実行すること</li>\n<li>Promiseオブジェクトの作成：newを使ってPromiseのインスタンスを作成する</li>\n<li>resolve：非同期処理が成功した時に呼び出されるメソッド</li>\n<li>reject：非同期処理が失敗した時に呼び出されるメソッド</li>\n<li>then：Promiseの結果（resolveされた時の処理、catchでrejectされた時の処理）を受け取る</li>\n<li>チェーン：複数の処理を連結させる処理</li>\n<li>Promise.all：すべての非同期処理が完了した時点で、resolveを返す処理</li>\n</ul>\n<h1>用語一覧</h1>\n<ul>\n<li>オブジェクト\nオブジェクトには、データを扱うためのプロパティとメソッドが含まれています。JavaやC++、C#などの言語ではこれをクラスと呼びます。プロパティやメソッドをまとめておいたもの、つまり他の言語のクラスに相当するものをJavaScriptではオブジェクトと呼んでいます。</li>\n</ul>\n<p>JavaScriptのオブジェクトは、実行環境の一部として組み込み済みなため、ユーザー自身が独自に作成しなくても使えます。</p>\n<ul>\n<li>\n<p>インスタンス化\nオブジェクトを生成することです。</p>\n</li>\n<li>\n<p>コンストラクタ\nインスタンスを作成する際に、初期化を行うメソッドのことです。</p>\n</li>\n<li>\n<p>インスタンスメソッド\nインスタンス化されたオブジェクトから呼び出したメソッドのことです。<br>\nthen, catch</p>\n</li>\n<li>\n<p>静的メソッド\nインスタンスを生成しなくても直接呼び出せるメソッドです。<br>\nPromise.all, Promise.resolve, Promise.rejectなど</p>\n</li>\n</ul>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - JavaScript | MDN</a></li>\n<li><a href=\"https://azu.github.io/promises-book/\">JavaScript Promiseの本</a></li>\n</ul>\n",
  "dir": "posts/json",
  "base": "20200427.json",
  "ext": ".json",
  "sourceBase": "20200427.md",
  "sourceExt": ".md"
}