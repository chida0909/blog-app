{
  "title": "Vue.jsスタイルガイド深堀り 優先度A",
  "permalink": "vue-style-guide",
  "description": "このページはVue.jsスタイルガイドの要約ではなく、個人的に調べた内容を肉付けした記事です。",
  "created_at": "2020-04-06T00:00:00.000Z",
  "tags": "Vue",
  "bodyContent": "このページはVue.jsスタイルガイドの要約ではなく、個人的に調べた内容を肉付けした記事です。対象範囲は、単一ファイルコンポーネント（.vue）に対してです。  \n[スタイルガイド — Vue.js](https://jp.vuejs.org/v2/style-guide/index.html)  \n\nルールカテゴリは以下のように定められていますが、優先度Aについて書きます。\n\n| 優先度 | 内容 |\n| ---- | ---- |\n| A:必須 | エラー防止 |\n| B:強く推奨 | (読みやすさの向上 |\n| C:推奨 | 一貫性の確保 |\n| D:使用注意 | 潜在的な不具合の回避 |\n\n# 複数単語コンポーネント名\nコンポーネント名は常に複数単語にします。全てのHTML要素は1単語のため、HTML要素との衝突を防止します。  \n\n**悪い例**  \n```\nexport default {\n  name: 'Todo',\n  // ...\n}\n```\n\n**良い例**  \n```\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n```\n\n# コンポーネントのデータ\nコンポーネントのdataは、オブジェクトを返す関数でなければなりません。  \n\n**悪い例**  \n```\nexport default {\n  data: {\n    foo: 'bar'\n  }\n}\n```\n\n**良い例**  \n```\nexport default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n```\n\n**補足**  \ndataの値がオブジェクトの時、コンポーネントの全てのインスタンスで共有されるため、他のインスタンスのdataの値を書き換えてしまいます。\n\n# プロパティの定義\nプロパティの定義はできる限り詳しく書きます。\n\n**悪い例**  \n```\nprops: ['status']\n```\n\n**良い例**  \n```\nprops: {\n  status: String\n}\n```\n\n**補足**  \n上記の例の場合、statusにString以外の型が渡されると、ディベロッパーツールのConsoleに警告を出して知らせてくれます。  \n\n以下のようにプロパティの定義を複数設定することもできます。\n```\nprops: {\n  status: {\n    type: String,\n    default: '',\n    required: true\n  }\n}\n```\n\n更にvalidatorを設定することができます。次の例では、配列statusの各文字数が10文字以下か否かのチェックをしています。everyメソッドを使うことで全ての値が10文字以上だった場合、trueを返すようにしています。\n```\nprops: {\n  status: {\n    type: Array,\n    required: true,\n    validator (arrayValue) {\n      return arrayValue.every( v => v.length <= 10 )\n    }\n  }\n}\n```\n\n# キー付き v-for\nkeyは仮想DOMの差分から実際のDOMに反映させるときに、最小限の変更するために使われます。差分算出のため、描画のパフォーマンスの向上に繋がります。  \n参考：[API — Vue.js](https://jp.vuejs.org/v2/api/#key)  \n\n\n**悪い例**  \n```\n<ul>\n  <li v-for=\"todo in todos\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n\n**良い例**  \n```\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n\n**補足**  \nDOMの内容が単純な場合や、要素の追加や削除がない場合に限り、keyを使わなくても問題はないようです。  \n参考：[リストレンダリング — Vue.js](https://jp.vuejs.org/v2/guide/list.html#状態の維持)  \n  \n&#13;&#10;\n  \n※v-forでkey属性にindexを使って良いのか問題  \n  \n&#13;&#10;\n  \nv-forで第2引数を指定すると、配列インデックスを受け取れます。  \n```\n<ul>\n  <li\n    v-for=\"(todo, index) in todos\"\n    :key=\"index\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n  \n&#13;&#10;\n  \n配列インデックスをkeyに指定するのは、結論NGです。要素の追加や削除があった場合、インデックスは振り直されるため、付与されていたインデックスが変わってしまいます。インデックスが変わると不具合を起こしかねません。  \n  \n&#13;&#10;\n  \n「インデックスが振り直される」のイメージを持っていただくため [サンプルページ](https://chida.blog/sample/keytest) を作成しました。ページ内ではユーザー名を並べています。id: usernameの形式で10名いますが、ボタンをクリックするとユーザーが削除され、keyが振り直されていることが確認できます。見た目上は削除できていますが、データ上「id = username」の関係にならないため、ユーザーの特定が不可になります（同姓同名が存在していたら、どれが正しいか判別できません）\n  \n&#13;&#10;\n  \nつまり、一意のidが振れない場合は、無理してインデックスは使うことはないです。ちなみにkeyを指定しない場合は、配列インデックスと同じ扱いになります。  \n  \n&#13;&#10;\n  \n参考：[Vue.js: v-forで項目インデックスをkey属性にしていいのか](https://qiita.com/FumioNonaka/items/d1d9c9335116426a8316)  \n\n# v-forと一緒にv-ifを使うのを避ける\nv-forはv-ifより優先度が高いため、内部でelementをループしてから、v-ifで条件をチェックすることになります。レンダリングされるたびに配列をすべて繰り返し処理するのは、描画コストがかかるためv-forとv-ifの併用は良くないです。\n\n**良い例**  \n```\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n**良い例**  \n```\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n**補足**  \ncomputedを使い状態をキャッシュさせておいて、値に変化があった場合のみ再評価を行う方法も検討できます。  \n\n```\n<template>\n  <ul>\n    <li\n      v-for=\"user in userList\"\n      :key=\"user.id\"\n    >\n    {{ user.name }}\n    </li>\n  </ul>\n</template>\n```\n\n```\n<script>\nexport default {\n  data() {\n    return {\n      users: [\n        { id: 0, name: \"yamada\", isActive: true },\n        { id: 1, name: \"saito\", isActive: false },\n        { id: 2, name: \"yoshida\", isActive: true }\n      ]\n    }\n  },\n  computed: {\n    userList () {\n      return this.users.filter(user => user.isActive)\n    }\n  }\n}\n</script>\n```\n\n# コンポーネントスタイルのスコープ\n\nコンポーネントのスタイルは以下のいずれかを使用します。  \n1. scoped\n2. CSS modules\n3. BEMなどのCSS設計  \n&#13;&#10;\n  \nこれらを使用しない場合はCSSがグローバル汚染され、他コンポーネントのstyleが上書きされる可能性があります。  \n\n**悪い例**\n```\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n\n**良い例**\n```\n<template>\n  <button class=\"button button-close\">X</button>\n</template>\n\n<!-- `scoped` を使用 -->\n<style scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n</style>\n```\n\n```\n<template>\n  <button :class=\"[$style.button, $style.buttonClose]\">X</button>\n</template>\n\n<!-- CSS modules を使用 -->\n<style module>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n</style>\n```\n\n```\n<template>\n  <button class=\"c-Button c-Button--close\">X</button>\n</template>\n\n<!-- BEM の慣例を使用 -->\n<style>\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n</style>\n```\n\n**補足**  \n【scopedの仕組み】\n  \n&#13;&#10;\n  \nscopedはHTMLにdata属性を付与し、元のclass名は変更しない仕組みになっています。  \n\n```html\n<!-- data属性を付与 -->\n<div data-v-5e5c8e78=\"\" class=\"content\">\n  ルールカテゴリ\n</div>\n```\n\n```css\n/* 属性セレクタを付与 */\n.content[data-v-5e5c8e78] {\n  margin: 16px;\n}\n```\n  \n&#13;&#10;\n  \n【CSS modulesの仕組み】  \n&#13;&#10;\n  \nmodulesはclass名にランダムな文字列を追加してくれます。  \n```html\n<div class=\"content_5cHmp\">\n  ルールカテゴリ\n</div>\n```\n\n```css\n.content_5cHmp {\n  margin: 16px;\n}\n```\n  \n&#13;&#10;\n  \nscopedとmodulesはどちらを使うかは、私が確認した範疇ではmodulesの方が支持されているようです。scopedは属性セレクタを利用するのでレンダリング速度が遅くなったり、親と子のコンポーネント間で同じCSSセレクタを指定した際に予期せぬ装飾がされる事があるそうです（modulesにもデメリットはありますが、文章が長くなるので割愛します）\n- [vue-loaderのScoped CSSのスタイルが子コンポーネントのルート要素に効いてしまって辛い - Qiita](https://qiita.com/yassh/items/7fb75904de19ff3bd3e8)  \n- [(5) スタイルの適用と閉じ込め - デザイナー向けのVue.js紹介｜noonworks｜note](https://note.com/noonworks/n/na6e34eed1d93)  \n- [スタックオーバーフロー](https://stackoverflow.com/questions/12279544/which-css-selectors-or-rules-can-significantly-affect-front-end-layout-renderi)  \n\n# プライベートなプロパティ名\n\nプロパティの衝突を避けるため、プラグインやミックスインなどのカスタムプロパティには、$_プレフィックスをします。  \n\n**悪い例**\n```\nvar myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n```\n\n**良い例**\n```\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n**補足**\n\nコンポーネントにミックスインをインポートすると、コンポーネントコードにミックスインコードが結合されますが、同名のプロパティがあった場合は、コンポーネントプロパティが優先され、オーバーラッピングを起します。この辺りの説明は、以下の記事に詳しく書いています。  \n\n[Vue開発者のためのVue.jsベストプラクティス集15選 - Qiita](https://qiita.com/mtoyopet/items/87a32d8e3497c5421727#12-ミックスインプロパティには_を使う)",
  "bodyHtml": "<p>このページはVue.jsスタイルガイドの要約ではなく、個人的に調べた内容を肉付けした記事です。対象範囲は、単一ファイルコンポーネント（.vue）に対してです。<br>\n<a href=\"https://jp.vuejs.org/v2/style-guide/index.html\">スタイルガイド — Vue.js</a></p>\n<p>ルールカテゴリは以下のように定められていますが、優先度Aについて書きます。</p>\n<table>\n<thead>\n<tr>\n<th>優先度</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A:必須</td>\n<td>エラー防止</td>\n</tr>\n<tr>\n<td>B:強く推奨</td>\n<td>(読みやすさの向上</td>\n</tr>\n<tr>\n<td>C:推奨</td>\n<td>一貫性の確保</td>\n</tr>\n<tr>\n<td>D:使用注意</td>\n<td>潜在的な不具合の回避</td>\n</tr>\n</tbody>\n</table>\n<h1>複数単語コンポーネント名</h1>\n<p>コンポーネント名は常に複数単語にします。全てのHTML要素は1単語のため、HTML要素との衝突を防止します。</p>\n<p><strong>悪い例</strong></p>\n<pre><code>export default {\n  name: 'Todo',\n  // ...\n}\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>export default {\n  name: 'TodoItem',\n  // ...\n}\n</code></pre>\n<h1>コンポーネントのデータ</h1>\n<p>コンポーネントのdataは、オブジェクトを返す関数でなければなりません。</p>\n<p><strong>悪い例</strong></p>\n<pre><code>export default {\n  data: {\n    foo: 'bar'\n  }\n}\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>export default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n</code></pre>\n<p><strong>補足</strong><br>\ndataの値がオブジェクトの時、コンポーネントの全てのインスタンスで共有されるため、他のインスタンスのdataの値を書き換えてしまいます。</p>\n<h1>プロパティの定義</h1>\n<p>プロパティの定義はできる限り詳しく書きます。</p>\n<p><strong>悪い例</strong></p>\n<pre><code>props: ['status']\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>props: {\n  status: String\n}\n</code></pre>\n<p><strong>補足</strong><br>\n上記の例の場合、statusにString以外の型が渡されると、ディベロッパーツールのConsoleに警告を出して知らせてくれます。</p>\n<p>以下のようにプロパティの定義を複数設定することもできます。</p>\n<pre><code>props: {\n  status: {\n    type: String,\n    default: '',\n    required: true\n  }\n}\n</code></pre>\n<p>更にvalidatorを設定することができます。次の例では、配列statusの各文字数が10文字以下か否かのチェックをしています。everyメソッドを使うことで全ての値が10文字以上だった場合、trueを返すようにしています。</p>\n<pre><code>props: {\n  status: {\n    type: Array,\n    required: true,\n    validator (arrayValue) {\n      return arrayValue.every( v =&gt; v.length &lt;= 10 )\n    }\n  }\n}\n</code></pre>\n<h1>キー付き v-for</h1>\n<p>keyは仮想DOMの差分から実際のDOMに反映させるときに、最小限の変更するために使われます。差分算出のため、描画のパフォーマンスの向上に繋がります。<br>\n参考：<a href=\"https://jp.vuejs.org/v2/api/#key\">API — Vue.js</a></p>\n<p><strong>悪い例</strong></p>\n<pre><code>&lt;ul&gt;\n  &lt;li v-for=&quot;todo in todos&quot;&gt;\n    {{ todo.text }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=&quot;todo in todos&quot;\n    :key=&quot;todo.id&quot;\n  &gt;\n    {{ todo.text }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p><strong>補足</strong><br>\nDOMの内容が単純な場合や、要素の追加や削除がない場合に限り、keyを使わなくても問題はないようです。<br>\n参考：<a href=\"https://jp.vuejs.org/v2/guide/list.html#%E7%8A%B6%E6%85%8B%E3%81%AE%E7%B6%AD%E6%8C%81\">リストレンダリング — Vue.js</a></p>\n<p>\r\n</p>\n<p>※v-forでkey属性にindexを使って良いのか問題</p>\n<p>\r\n</p>\n<p>v-forで第2引数を指定すると、配列インデックスを受け取れます。</p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=&quot;(todo, index) in todos&quot;\n    :key=&quot;index&quot;\n  &gt;\n    {{ todo.text }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>\r\n</p>\n<p>配列インデックスをkeyに指定するのは、結論NGです。要素の追加や削除があった場合、インデックスは振り直されるため、付与されていたインデックスが変わってしまいます。インデックスが変わると不具合を起こしかねません。</p>\n<p>\r\n</p>\n<p>「インデックスが振り直される」のイメージを持っていただくため <a href=\"https://chida.blog/sample/keytest\">サンプルページ</a> を作成しました。ページ内ではユーザー名を並べています。id: usernameの形式で10名いますが、ボタンをクリックするとユーザーが削除され、keyが振り直されていることが確認できます。見た目上は削除できていますが、データ上「id = username」の関係にならないため、ユーザーの特定が不可になります（同姓同名が存在していたら、どれが正しいか判別できません）</p>\n<p>\r\n</p>\n<p>つまり、一意のidが振れない場合は、無理してインデックスは使うことはないです。ちなみにkeyを指定しない場合は、配列インデックスと同じ扱いになります。</p>\n<p>\r\n</p>\n<p>参考：<a href=\"https://qiita.com/FumioNonaka/items/d1d9c9335116426a8316\">Vue.js: v-forで項目インデックスをkey属性にしていいのか</a></p>\n<h1>v-forと一緒にv-ifを使うのを避ける</h1>\n<p>v-forはv-ifより優先度が高いため、内部でelementをループしてから、v-ifで条件をチェックすることになります。レンダリングされるたびに配列をすべて繰り返し処理するのは、描画コストがかかるためv-forとv-ifの併用は良くないです。</p>\n<p><strong>良い例</strong></p>\n<pre><code>&lt;ul&gt;\n  &lt;li\n    v-for=&quot;user in users&quot;\n    v-if=&quot;shouldShowUsers&quot;\n    :key=&quot;user.id&quot;\n  &gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;\n  &lt;li\n    v-for=&quot;user in users&quot;\n    :key=&quot;user.id&quot;\n  &gt;\n    {{ user.name }}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p><strong>補足</strong><br>\ncomputedを使い状態をキャッシュさせておいて、値に変化があった場合のみ再評価を行う方法も検討できます。</p>\n<pre><code>&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li\n      v-for=&quot;user in userList&quot;\n      :key=&quot;user.id&quot;\n    &gt;\n    {{ user.name }}\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code>&lt;script&gt;\nexport default {\n  data() {\n    return {\n      users: [\n        { id: 0, name: &quot;yamada&quot;, isActive: true },\n        { id: 1, name: &quot;saito&quot;, isActive: false },\n        { id: 2, name: &quot;yoshida&quot;, isActive: true }\n      ]\n    }\n  },\n  computed: {\n    userList () {\n      return this.users.filter(user =&gt; user.isActive)\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h1>コンポーネントスタイルのスコープ</h1>\n<p>コンポーネントのスタイルは以下のいずれかを使用します。</p>\n<ol>\n<li>scoped</li>\n<li>CSS modules</li>\n<li>BEMなどのCSS設計<br>\n\r\n</li>\n</ol>\n<p>これらを使用しない場合はCSSがグローバル汚染され、他コンポーネントのstyleが上書きされる可能性があります。</p>\n<p><strong>悪い例</strong></p>\n<pre><code>&lt;template&gt;\n  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n.btn-close {\n  background-color: red;\n}\n&lt;/style&gt;\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>&lt;template&gt;\n  &lt;button class=&quot;button button-close&quot;&gt;X&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;!-- `scoped` を使用 --&gt;\n&lt;style scoped&gt;\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n&lt;/style&gt;\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;button :class=&quot;[$style.button, $style.buttonClose]&quot;&gt;X&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;!-- CSS modules を使用 --&gt;\n&lt;style module&gt;\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n&lt;/style&gt;\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;\n&lt;/template&gt;\n\n&lt;!-- BEM の慣例を使用 --&gt;\n&lt;style&gt;\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n&lt;/style&gt;\n</code></pre>\n<p><strong>補足</strong><br>\n【scopedの仕組み】</p>\n<p>\r\n</p>\n<p>scopedはHTMLにdata属性を付与し、元のclass名は変更しない仕組みになっています。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">&lt;!-- data属性を付与 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-v-5e5c8e78</span>=<span class=\"hljs-string\">\"\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span>\n  ルールカテゴリ\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre><pre><code class=\"hljs\"><span class=\"hljs-comment\">/* 属性セレクタを付与 */</span>\n<span class=\"hljs-selector-class\">.content</span><span class=\"hljs-selector-attr\">[data-v-5e5c8e78]</span> {\n  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">16px</span>;\n}</code></pre><p>\r\n</p>\n<p>【CSS modulesの仕組み】<br>\n\r\n</p>\n<p>modulesはclass名にランダムな文字列を追加してくれます。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content_5cHmp\"</span>&gt;</span>\n  ルールカテゴリ\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre><pre><code class=\"hljs\"><span class=\"hljs-selector-class\">.content_5cHmp</span> {\n  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">16px</span>;\n}</code></pre><p>\r\n</p>\n<p>scopedとmodulesはどちらを使うかは、私が確認した範疇ではmodulesの方が支持されているようです。scopedは属性セレクタを利用するのでレンダリング速度が遅くなったり、親と子のコンポーネント間で同じCSSセレクタを指定した際に予期せぬ装飾がされる事があるそうです（modulesにもデメリットはありますが、文章が長くなるので割愛します）</p>\n<ul>\n<li><a href=\"https://qiita.com/yassh/items/7fb75904de19ff3bd3e8\">vue-loaderのScoped CSSのスタイルが子コンポーネントのルート要素に効いてしまって辛い - Qiita</a></li>\n<li><a href=\"https://note.com/noonworks/n/na6e34eed1d93\">(5) スタイルの適用と閉じ込め - デザイナー向けのVue.js紹介｜noonworks｜note</a></li>\n<li><a href=\"https://stackoverflow.com/questions/12279544/which-css-selectors-or-rules-can-significantly-affect-front-end-layout-renderi\">スタックオーバーフロー</a></li>\n</ul>\n<h1>プライベートなプロパティ名</h1>\n<p>プロパティの衝突を避けるため、プラグインやミックスインなどのカスタムプロパティには、$_プレフィックスをします。</p>\n<p><strong>悪い例</strong></p>\n<pre><code>var myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n</code></pre>\n<p><strong>良い例</strong></p>\n<pre><code>var myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n</code></pre>\n<p><strong>補足</strong></p>\n<p>コンポーネントにミックスインをインポートすると、コンポーネントコードにミックスインコードが結合されますが、同名のプロパティがあった場合は、コンポーネントプロパティが優先され、オーバーラッピングを起します。この辺りの説明は、以下の記事に詳しく書いています。</p>\n<p><a href=\"https://qiita.com/mtoyopet/items/87a32d8e3497c5421727#12-%E3%83%9F%E3%83%83%E3%82%AF%E3%82%B9%E3%82%A4%E3%83%B3%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E3%81%AB%E3%81%AF_%E3%82%92%E4%BD%BF%E3%81%86\">Vue開発者のためのVue.jsベストプラクティス集15選 - Qiita</a></p>\n",
  "dir": "posts/json",
  "base": "20200406.json",
  "ext": ".json",
  "sourceBase": "20200406.md",
  "sourceExt": ".md"
}